(ns lounge.bot
  (:require [tailrecursion.javelin :refer [cell]]
            [crate.binding :refer [sub-swap! subatom sub-reset! deref?]])
  (:require-macros [tailrecursion.javelin :refer [cell=]]))

(def +obj-id+ (cell 0))

(def object-defs (cell {}))

(def instances (cell (sorted-map)))

;;sync refrence links
(defn refresh! [obj]
  ())


(defn update-in! [obj & r]
  (swap! obj #(apply update-in % r)))

(defn by-tag [tag]
  (sort-by (comp ::id deref)
           (filter #(when-let [ts (:tags (deref %))]
                      (ts tag))
                   (vals @instances))))

(defn by-type [coll type]
  (filter #(= type (::type (deref %))) (vals coll)))

(defn by-name [coll name]
  (filter #(= name (:name (deref %))) (vals coll)))

(defn inst-by-type [type]
  (by-type @instances type))

(defn inst-by-name [name]
  (by-name @instances name))

(defn objdef-by-type [type]
  (by-type @object-defs type))

(defn obj-id [obj]
  (if (deref? obj)
    (::id @obj)
    (::id obj)))

(defn obj-def* [name map basetype]
  (let [base    (or (@object-defs basetype) nil)
        default {::type name}
        obj (merge base
                   default
                   (dissoc map :name))]
    (when (contains? map ::type)
      (reset! object-defs (assoc object-defs (::type map) map)))))

(obj-def* ::object {:behaviors #{}
                    :events #{}
                    :tags #{:object}}
          nil)

(obj-def* ::behavior {:action nil
                      :events #{}
                      :tags #{:behavior}}
          nil)

(obj-def* ::tag {:behaviors #{}
                 :children #{}
                 :events #{}
                 :listeners #{}
                 :tags #{:tag}}
          nil)


(defn obj-create [obj-name map basetype & args]
  (let [obj     (@object-defs basetype)
        id      (or (::id obj) (swap! +obj-id+ inc))
        new-obj (cell (merge obj
                             map
                             {:name obj-name
                              ::id id
                              :args (merge (:args obj) args)
                              :behaviors (set (:behaviors obj))
                              :tags (set (conj (:tags obj) :object))}))]
    (swap! instances assoc (::id @new-obj) new-obj)
    new-obj))

(defn +bot! [obj prop sub]
  (update-in! obj [prop] conj sub))

(defn -bot! [obj prop sub]
  (update-in! obj [prop] disj sub))

(defn raise [obj b])
